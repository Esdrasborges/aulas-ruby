<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Listas</title>
</head>
<body>
    <h1>Arrays</h1>
<p>Uma estrutura muito utilizada quando escrevemos código são os arrays. Basicamente são listas ordenadas de elementos é uma estrutura capaz de armazenar um conjunto de valores sem a necessidade de criar várias variáveis.
Em Ruby, um array é declarado com a notação de colchetes [] e a primeira posição de um array será sempre 0 (zero). No exemplo abaixo, criamos um array chamado alunos e inserimos valores nas posições 0, 1 e 2.

alunos = ['André', 'Pedro', 'Carolina']
alunos = ['André', 'Pedro', 'Carolina']
alunos[0] # "André"
alunos[1] # "Pedro"
alunos[-1] # último elemento do array, nesse caso, "Carolina"

Em Ruby os arrays são dinâmicos, portanto você não precisa definir seu tamanho inicial, mas se preferir definir você também pode. Caso tenha criado um array com 10 posições e precise guardar um novo dado no array, você poderá fazê-lo sem problemas pois o array será expandido automaticamente conforme a necessidade.

Diferentemente de outras linguagens, em Ruby os arrays também podem guardar tipos de dados distintos. Portanto, você pode guardar uma String na primeira posição, um número inteiro na segunda, um número real na terceira, um objeto na quarta, etc.
Em Ruby, podemos adicionar e remover itens sem essa preocupação. Acrescentar ou remover itens de um array também é muito simples em Ruby:

alunos << 'Laura' # adiciona o valor "Laura" na última posição do array alunos 
alunos.pop() # remove o último valor do array, nesse caso, “Laura”
</p>
<h2>Iterando em arrays</h2>
<h3>Método EACH DO</h3>
<>É muito comum, em diversas situações, precisarmos iterar, ou seja, verificar cada um dos elementos de um array, e fazer algum processamento se for necessário.
Exemplo: 

meu_array = [10, 20, 30, 40, 50]

meu_array.each do |elemento|
  puts elemento
end

Na linha 1, criamos um array com cinco elementos numéricos quaisquer. Na linha 3, usamos o método each no meu_array para que possamos iterar entre seus elementos. A cada iteração do laço, um dos valores armazenados no meu_array será atribuído à variável elemento (definida entre | e |). Portanto, nesse caso, na primeira iteração, o valor de elemento será 10; na segunda iteração, o valor de elemento será 20; na terceira iteração, o valor de elemento será 30, e assim sucessivamente, até que a variável elemento tenha assumido o valor de cada posição do meu_array. Vale salientar que, o nome da variável elemento é definido pelo próprio programador, obedecendo as normas de nomenclatura de variáveis.
<H3>Método MAP</H3>
<p>Cria um Array baseando-se em valores de outro array existente.Diferente do each visto a cima em vários aspectos, o mais visível sem dúvidas é a sua característica de retornar um Array com o resultado do bloco aplicado para cada elemento recebido.
Primeiro, você tem um array, mas também pode ser um hash ou um intervalo.

Então você paga map com um bloco. O bloco é essa coisa entre colchetes { ... }. Dentro do bloco, você diz COMO deseja transformar cada elemento no array. É basicamente uma função.
Números duplicados :

matriz = [ 1 , 2 , 3 ]
new_matriz = matriz.map do |n|   
puts n * 2
end
puts new_matriz

#[2, 4, 6]

Converter strings em inteiros :

matriz = [ "11" , "21" , "5" ]
variedade.map { |str| estr.to_i }  
# [11, 21, 5]
</p>
<h1>Select</h1>
<p>O .select permite que você selecione elementos de um Array conforme os critérios que estipular. Você precisa passar para ele, como parâmetro, uma função que retorne um boolean, assim ele retornará um Array com os elementos que resultarem em verdadeiro (true).</p>
<h1>Hash</h1>
<p>Os hashes também são estruturas de dados, bem semelhantes aos arrays, que guardam um conjunto de dados. A principal diferença entre os arrays e os hashes é que, nos arrays cada posição é "endereçada" (indexada) por um número inteiro, enquanto nos hashes, cada posição é endereçada por uma chave.
Uma definição muito simples para os hashes é que eles são uma coleção de pares chave-valor. Confira a Figura 1, que ilustra a estrutura de um hash. 
<img src="https://ifrnead.github.io/rubynapratica/assets/images/estrutura-hash.png" alt=""></p>
<p>Observe, na Figura 1, que a estrutura de um hash é muito semelhante à estrutura de um array, pois, conforme explicado anteriormente, ambas são estruturas que armazenam um conjunto de dados, evitando a criação de muitas variáveis. Observe também que cada posição do hash é marcada por uma chave. No caso do hash ilustrado na Figura 1, as chaves são Strings.

Contudo, as chaves dos hashes também podem ser qualquer tipo de dado, inclusive símbolos (Symbol).
O hash, que é um conjunto de pares com uma chave e um valor. Com ele, podemos nomear nossos atributos, como um dicionário.

aluno = { nome: 'João', nota: 7, disciplina: 'Ciências' }
puts aluno[:nome]
puts aluno[:disciplina]
aluno[:nome] = 'Maria'
puts aluno[:nome]
Para criar um hash em Ruby basta usar chaves {} e, dentro dessas chaves, declarar os pares de chave e valor separados por :. Para acessar um dado de um hash, basta usar colchetes [] com a chave correspondente. O comando retornará o valor associado à chave. Caso a chave não exista, será retornado nil (nulo).
</p>
<h1>Estruturas de controle de fluxo condicionais</h1>
<p>Estruturas de controle de fluxo, são comandos e instruções que nos permitem controlar como a execução do código será realizada. Os códigos que produzimos até o presente momento não incluíram nenhuma estrutura de controle de fluxo, e, portanto, a execução deles é simplesmente linear, ou seja, inicia na primeira linha, segue a execução das linhas seguintes e termina na última, sem nenhum trecho de código condicional ou repetição.
</p>
<h2>Estruturas condicionais: if e else</h2>
<p>Expressaõ que verificar se uma condição é verdadeira(tue), e a partir desse resultado determina se as instruções dentro do seu corpo(estrutura) serão ou não execultadas.
  if condicao
  # trecho de código a ser executado quando a condição for verdadeira
 end
Exemplo: 
  odd?() # verifica se 7 é ímpar e retorna true
  even?() # verifica se 4 é par e retorna true
  if 1.odd?()
    puts '1 é um número ímpar.'
 end
 A primeira linha do código acima é uma condição “se 1 for ímpar”. Na linha seguinte, com um recuo de dois espaços para mostrar que o código está dentro do if, há um código que só será executado se a condição for verdadeira. Então terminamos com a palavra end. Ela mostra que acabamos de escrever tudo o que queremos executar se aquela condição for verdadeira.
</p>
<h2>Switch/Case</h2>
<p>O case é uma estrutura condicional interessante que nos permite substituir vários testes com if.
Com ela podemos facilmente definir uma série de condições e respostas, reduzindo muito a quantidade de código escrita. A estrutura switch consiste em definir a variável que será avaliada, seguida das condições e respostas.
 Exemplo:
 nota = 7
 case nota
 when 0
   puts 'Você tirou zero! Precisa melhorar…'
 when 1..4
   puts 'Reprovado… precisa se esforçar mais...'
 when 5
   puts 'Passou raspando!'
 when 6..9
   puts 'Parabéns, você foi aprovado.'
 else
   puts 'Tirou 10! Você deve ser o melhor aluno que já tive!'
 end 
</p>
<h2>Unless</h2>
<p>O unless, que em inglês significa "a menos que", tem um comportamento inverso ao do if. O trecho de código abaixo do if é executado quando a condição é verdadeira. O trecho de código abaixo do unless é executado quando a condição for falsa. 
  unless condicao
  # trecho de código a ser executado quando a condição for falsa
  end
No Exemplo de código 10, o trecho de código da linha 2 só será executado quando a condição do unless for falsa. Para exemplificar o uso do unless, vamos usar um método chamado empty?. O método empty? é executado sobre uma variável que guarda uma string e verifica se ela está vazia ou não, portanto, seria o equivalente a testar variavel == "". Esse método retorna true quando a string está vazia, e false caso contrário.
  Exemplo:
  puts "Digite o seu nome:"
  nome = gets.chomp
  
  if nome.empty?
    puts "Você não digitou seu nome."
  end
</p>
<h1>Estruturas de Repetição</h1>
<h2>While (ENQUANTO)</h2>
<p>O while é uma estrutura de repetição que reproduz um trecho de código enquanto uma determinada condição é satisfeita, ou seja, ENQUANTO a condição for verdadeira o código será execuldado
Exemplo:
  condicao = true
  while condicao
    puts "Digite um número múltiplo de 5: "
    numero = gets.chomp.to_i
    if numero % 5 == 0
      condicao = false
    end
  end
  puts "#{numero} é múltiplo de 5!"
</p>
<h2>For (PARA)</h2>
<p>O for é uma estrutura de repetição que executa um trecho de código várias vezes. Cada execução do for é chamada de iteração. Portanto dizemos que um for que executa 10 vezes possui 10 iterações.
  for i in 1..10
  puts "O valor de i é #{i}"
end
Observe, no Exemplo de código , que declaramos a variável i. Essa variável só existe dentro do for e ela assume um valor entre 1 e 10 a cada iteração. Na primeira execução do for, o valor de i é 1; na segunda execução do for, o valor de i é 2; na terceira execução do for, o valor de i é 3, e assim sucessivamente. O último valor que a variável i vai receber é 10.
</p>
<h2>Loop do</h2>
<p>Em Ruby, a looppalavra-chave é usada para criar um loop infinito. O código dentro do loop continuará a ser executado até que você saia explicitamente do loop usando uma breakinstrução.
Aqui está um exemplo de como usar a looppalavra-chave em Ruby:
loop do
        # code to be executed repeatedly
puts "Hello, world!"
end

No exemplo acima, a puts "Hello, world!"instrução será executada repetidamente até que o loop seja interrompido.

Para sair do loop, você pode usar a breakpalavra-chave. Por exemplo, você pode modificar o exemplo acima para sair do loop depois de imprimir a mensagem 10 vezes:
  count = 0
  loop do
    puts "Hello, world!"
    count += 1
    break if count == 10
  end

No exemplo acima, a count variável é inicializada em 0 e incrementada em 1 a cada iteração do loop. A break if count == 10instrução verifica se o valor de counté igual a 10 e sai do loop se for. Isso garantirá que a mensagem seja impressa exatamente 10 vezes antes que o loop seja encerrado.
</p>
<h2>Métodos</h2>
<p>gerenciáveis ​​e fáceis de entender.

Em Ruby, um método é definido usando a palavra-chave def, seguido do nome do método e, opcionalmente, uma lista de parâmetros entre parênteses. O corpo do método é colocado entre chaves ou em uma estrutura do...end.
  
  Por exemplo, o seguinte código define um método simples em Ruby que recebe um argumento nome e imprime na tela:
    def saudacao(nome)
       puts "Olá, #{nome}!"
    end
Depois de definido, o método pode ser chamado em qualquer lugar do código, passando pelos argumentos necessários:

    saudacao("João") # => Olá, João!
    saudacao("Maria") # => Olá, Maria!

Métodos em Ruby também podem retornar valores usando a palavra-chave return, embora isso seja opcional. Se o método não especificar explicitamente um valor de retorno, ele retornará implicitamente o valor da última expressão avaliada dentro do método.
</p>
</body>
</html>
