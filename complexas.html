<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Listas</title>
</head>
<body>
    <h1>Arrays</h1>
<p>Uma estrutura muito utilizada quando escrevemos código são os arrays. Basicamente são listas ordenadas de elementos é uma estrutura capaz de armazenar um conjunto de valores sem a necessidade de criar várias variáveis.
Em Ruby, um array é declarado com a notação de colchetes [] e a primeira posição de um array será sempre 0 (zero). No exemplo abaixo, criamos um array chamado alunos e inserimos valores nas posições 0, 1 e 2.

alunos = ['André', 'Pedro', 'Carolina']
alunos = ['André', 'Pedro', 'Carolina']
alunos[0] # "André"
alunos[1] # "Pedro"
alunos[-1] # último elemento do array, nesse caso, "Carolina"

Em Ruby os arrays são dinâmicos, portanto você não precisa definir seu tamanho inicial, mas se preferir definir você também pode. Caso tenha criado um array com 10 posições e precise guardar um novo dado no array, você poderá fazê-lo sem problemas pois o array será expandido automaticamente conforme a necessidade.

Diferentemente de outras linguagens, em Ruby os arrays também podem guardar tipos de dados distintos. Portanto, você pode guardar uma String na primeira posição, um número inteiro na segunda, um número real na terceira, um objeto na quarta, etc.
Em Ruby, podemos adicionar e remover itens sem essa preocupação. Acrescentar ou remover itens de um array também é muito simples em Ruby:

alunos << 'Laura' # adiciona o valor "Laura" na última posição do array alunos 
alunos.pop() # remove o último valor do array, nesse caso, “Laura”
</p>
<h2>Iterando em arrays</h2>
<h3>Método EACH DO</h3>
<>É muito comum, em diversas situações, precisarmos iterar, ou seja, verificar cada um dos elementos de um array, e fazer algum processamento se for necessário.
Exemplo: 

meu_array = [10, 20, 30, 40, 50]

meu_array.each do |elemento|
  puts elemento
end

Na linha 1, criamos um array com cinco elementos numéricos quaisquer. Na linha 3, usamos o método each no meu_array para que possamos iterar entre seus elementos. A cada iteração do laço, um dos valores armazenados no meu_array será atribuído à variável elemento (definida entre | e |). Portanto, nesse caso, na primeira iteração, o valor de elemento será 10; na segunda iteração, o valor de elemento será 20; na terceira iteração, o valor de elemento será 30, e assim sucessivamente, até que a variável elemento tenha assumido o valor de cada posição do meu_array. Vale salientar que, o nome da variável elemento é definido pelo próprio programador, obedecendo as normas de nomenclatura de variáveis.
<H3>Método MAP</H3>
<p>Cria um Array baseando-se em valores de outro array existente.Diferente do each visto a cima em vários aspectos, o mais visível sem dúvidas é a sua característica de retornar um Array com o resultado do bloco aplicado para cada elemento recebido.
Primeiro, você tem um array, mas também pode ser um hash ou um intervalo.

Então você paga map com um bloco. O bloco é essa coisa entre colchetes { ... }. Dentro do bloco, você diz COMO deseja transformar cada elemento no array. É basicamente uma função.
Números duplicados :

matriz = [ 1 , 2 , 3 ]
new_matriz = matriz.map do |n|   
puts n * 2
end
puts new_matriz

#[2, 4, 6]

Converter strings em inteiros :

matriz = [ "11" , "21" , "5" ]
variedade.map { |str| estr.to_i }  
# [11, 21, 5]
</p>
<h1>Select</h1>
<p>O .select permite que você selecione elementos de um Array conforme os critérios que estipular. Você precisa passar para ele, como parâmetro, uma função que retorne um boolean, assim ele retornará um Array com os elementos que resultarem em verdadeiro (true).</p>
</body>
</html>
