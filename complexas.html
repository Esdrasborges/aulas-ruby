<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Listas</title>
</head>
<body>
    <h1>Arrays</h1>
<p>Uma estrutura muito utilizada quando escrevemos código são os arrays. Basicamente são listas ordenadas de elementos é uma estrutura capaz de armazenar um conjunto de valores sem a necessidade de criar várias variáveis.
Em Ruby, um array é declarado com a notação de colchetes [] e a primeira posição de um array será sempre 0 (zero). No exemplo abaixo, criamos um array chamado alunos e inserimos valores nas posições 0, 1 e 2.

alunos = ['André', 'Pedro', 'Carolina']
alunos = ['André', 'Pedro', 'Carolina']
alunos[0] # "André"
alunos[1] # "Pedro"
alunos[-1] # último elemento do array, nesse caso, "Carolina"

Em Ruby os arrays são dinâmicos, portanto você não precisa definir seu tamanho inicial, mas se preferir definir você também pode. Caso tenha criado um array com 10 posições e precise guardar um novo dado no array, você poderá fazê-lo sem problemas pois o array será expandido automaticamente conforme a necessidade.

Diferentemente de outras linguagens, em Ruby os arrays também podem guardar tipos de dados distintos. Portanto, você pode guardar uma String na primeira posição, um número inteiro na segunda, um número real na terceira, um objeto na quarta, etc.
Em Ruby, podemos adicionar e remover itens sem essa preocupação. Acrescentar ou remover itens de um array também é muito simples em Ruby:

alunos << 'Laura' # adiciona o valor "Laura" na última posição do array alunos 
alunos.pop() # remove o último valor do array, nesse caso, “Laura”
</p>
<h2>Iterando em arrays</h2>
<h3>Método EACH DO</h3>
<>É muito comum, em diversas situações, precisarmos iterar, ou seja, verificar cada um dos elementos de um array, e fazer algum processamento se for necessário.
Exemplo: 

meu_array = [10, 20, 30, 40, 50]

meu_array.each do |elemento|
  puts elemento
end

Na linha 1, criamos um array com cinco elementos numéricos quaisquer. Na linha 3, usamos o método each no meu_array para que possamos iterar entre seus elementos. A cada iteração do laço, um dos valores armazenados no meu_array será atribuído à variável elemento (definida entre | e |). Portanto, nesse caso, na primeira iteração, o valor de elemento será 10; na segunda iteração, o valor de elemento será 20; na terceira iteração, o valor de elemento será 30, e assim sucessivamente, até que a variável elemento tenha assumido o valor de cada posição do meu_array. Vale salientar que, o nome da variável elemento é definido pelo próprio programador, obedecendo as normas de nomenclatura de variáveis.
<H3>Método MAP</H3>
<p>Cria um Array baseando-se em valores de outro array existente.Diferente do each visto a cima em vários aspectos, o mais visível sem dúvidas é a sua característica de retornar um Array com o resultado do bloco aplicado para cada elemento recebido.
Primeiro, você tem um array, mas também pode ser um hash ou um intervalo.

Então você paga map com um bloco. O bloco é essa coisa entre colchetes { ... }. Dentro do bloco, você diz COMO deseja transformar cada elemento no array. É basicamente uma função.
Números duplicados :

matriz = [ 1 , 2 , 3 ]
new_matriz = matriz.map do |n|   
puts n * 2
end
puts new_matriz

#[2, 4, 6]

Converter strings em inteiros :

matriz = [ "11" , "21" , "5" ]
variedade.map { |str| estr.to_i }  
# [11, 21, 5]
</p>
<h1>Select</h1>
<p>O .select permite que você selecione elementos de um Array conforme os critérios que estipular. Você precisa passar para ele, como parâmetro, uma função que retorne um boolean, assim ele retornará um Array com os elementos que resultarem em verdadeiro (true).</p>
<h1>Hash</h1>
<p>Os hashes também são estruturas de dados, bem semelhantes aos arrays, que guardam um conjunto de dados. A principal diferença entre os arrays e os hashes é que, nos arrays cada posição é "endereçada" (indexada) por um número inteiro, enquanto nos hashes, cada posição é endereçada por uma chave.
Uma definição muito simples para os hashes é que eles são uma coleção de pares chave-valor. Confira a Figura 1, que ilustra a estrutura de um hash. 
<img src="https://ifrnead.github.io/rubynapratica/assets/images/estrutura-hash.png" alt=""></p>
<p>Observe, na Figura 1, que a estrutura de um hash é muito semelhante à estrutura de um array, pois, conforme explicado anteriormente, ambas são estruturas que armazenam um conjunto de dados, evitando a criação de muitas variáveis. Observe também que cada posição do hash é marcada por uma chave. No caso do hash ilustrado na Figura 1, as chaves são Strings.

Contudo, as chaves dos hashes também podem ser qualquer tipo de dado, inclusive símbolos (Symbol).
O hash, que é um conjunto de pares com uma chave e um valor. Com ele, podemos nomear nossos atributos, como um dicionário.

aluno = { nome: 'João', nota: 7, disciplina: 'Ciências' }
puts aluno[:nome]
puts aluno[:disciplina]
aluno[:nome] = 'Maria'
puts aluno[:nome]
Para criar um hash em Ruby basta usar chaves {} e, dentro dessas chaves, declarar os pares de chave e valor separados por :. Para acessar um dado de um hash, basta usar colchetes [] com a chave correspondente. O comando retornará o valor associado à chave. Caso a chave não exista, será retornado nil (nulo).
</p>
<h1>Estruturas de controle de fluxo condicionais</h1>
<p>Estruturas de controle de fluxo, são comandos e instruções que nos permitem controlar como a execução do código será realizada. Os códigos que produzimos até o presente momento não incluíram nenhuma estrutura de controle de fluxo, e, portanto, a execução deles é simplesmente linear, ou seja, inicia na primeira linha, segue a execução das linhas seguintes e termina na última, sem nenhum trecho de código condicional ou repetição.
</p>
<h2>Estruturas condicionais: if e else</h2>
<p>Expressaõ que verificar se uma condição é verdadeira(tue), e a partir desse resultado determina se as instruções dentro do seu corpo(estrutura) serão ou não execultadas.
  if condicao
  # trecho de código a ser executado quando a condição for verdadeira
 end
Exemplo: 
  odd?() # verifica se 7 é ímpar e retorna true
  even?() # verifica se 4 é par e retorna true
  if 1.odd?()
    puts '1 é um número ímpar.'
 end
 A primeira linha do código acima é uma condição “se 1 for ímpar”. Na linha seguinte, com um recuo de dois espaços para mostrar que o código está dentro do if, há um código que só será executado se a condição for verdadeira. Então terminamos com a palavra end. Ela mostra que acabamos de escrever tudo o que queremos executar se aquela condição for verdadeira.
</p>
<h2>Switch/Case</h2>
<p>O case é uma estrutura condicional interessante que nos permite substituir vários testes com if.
Com ela podemos facilmente definir uma série de condições e respostas, reduzindo muito a quantidade de código escrita. A estrutura switch consiste em definir a variável que será avaliada, seguida das condições e respostas.
 Exemplo:
 nota = 7
 case nota
 when 0
   puts 'Você tirou zero! Precisa melhorar…'
 when 1..4
   puts 'Reprovado… precisa se esforçar mais...'
 when 5
   puts 'Passou raspando!'
 when 6..9
   puts 'Parabéns, você foi aprovado.'
 else
   puts 'Tirou 10! Você deve ser o melhor aluno que já tive!'
 end 
</p>
</body>
</html>
